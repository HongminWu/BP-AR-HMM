%@HongminWu March 22,2017
% testing_all_learned_models_VS_1_trial
% 4 models + 1 observation
%1. load all the learned models in a cell named as 'learnedModel'
%2. load the testing trial
function static_test_state_classification(trialID)
global  TRAINED_MODEL_PATH DATA_PATH DATASET TESTING_RESULTS_PATH PLOT_SAVE
global  METHOD ROBOT TASK STATE AUTOREGRESSIVE_ORDER
global  TRAINING_SUCCESS_FAILURE TRAINING_SIM_REAL
global  TESTING_SUCCESS_FAILURE TESTING_SIM_REAL
global  TIME_STEP COLORS
global  CONFUSION_MATRIX TIME_PERCENT 

%initial parameters
trainedModel                      = {};
stateData                         = {};
data_struct                       = struct;
[dataCell, R_State, FOLDERS_NAME] = load_data(strcat(DATA_PATH, '/', DATASET), trialID);
dataCell                          = data_preprocessing(dataCell); % mean = 0 and covariance = Unit matrix
data                              = dataCell{1};
R_State                           = R_State{1};
% step-1: find out the optimal model, load the data for each state, 
%         load the expected-log_likelihood, which generated by script 'calculate_state_threshold'
for nState = 1 : length(STATE) 
     file                      = dir([strcat(TRAINED_MODEL_PATH,char(STATE(nState)),'/') strcat('*','.mat')]); 
     stateModel                = load(strcat(TRAINED_MODEL_PATH,char(STATE(nState)),'/',file(1).name));                                 %for initializating the 'meanmodel'
     trainedModel              = [trainedModel, {stateModel}];
     sData                     = data(:,R_State(nState):R_State(nState + 1));
     stateData                 = [stateData, {sData}];  
end

% step-2: calculate the cumlative log-likelihood for each state, and store in the 'stateLikelihood' array.
    stateLikelihood           = zeros(length(STATE),R_State(end));
    STATE_STATUS              =[]; 
for nState = 1:length(STATE)
    disp(strcat('Testing:',char(STATE(nState))));
    sensor                        = stateData{nState};
    data_struct.obs               = sensor;
    data_struct.true_labels       = ones(1,size(sensor,2));
    data_struct.test_cases        = 1;
    data_struct.blockSize         = ones(1,size(sensor,2));
    data_struct.blockEnd          = 1:size(sensor,2);
    
    [X,valid]                     = makeDesignMatrix(data_struct.obs,AUTOREGRESSIVE_ORDER);
    data_struct.obs               = data_struct.obs(:,find(valid));
    data_struct.X                 = X(:,find(valid));
    data_struct.blockSize         = ones(1,size(data_struct.obs,2));
    data_struct.blockEnd          = cumsum(data_struct.blockSize);
    data_struct.true_labels       = data_struct.true_labels(find(valid));
    state_end = [];
    state_log = [];
    for nModel = 1:length(trainedModel) %  the same data for different state model
        %testing the observed data for each learned model
        dist_struct               = trainedModel{nModel}.BPARHMM_dist_struct(1); 
        theta                     = trainedModel{nModel}.BPARHMM_theta;
        F                         = trainedModel{nModel}.BPARHMM_F(1,:);
        [testing_total_log_likelihood,...
            testing_neglog_c]     = observation_likelihood(F, data_struct,'AR', dist_struct,theta);   
            stateLikelihood(nModel,R_State(nState) + AUTOREGRESSIVE_ORDER:R_State(nState + 1))     =  cumsum(testing_neglog_c); %
            state_end = [state_end, sum(testing_neglog_c)];
            state_log = [state_log; cumsum(testing_neglog_c)];
    end  
     %state classification
     [~, index] = max(state_end);
     if index == nState
         CONFUSION_MATRIX(nState, nState) = CONFUSION_MATRIX(nState, nState) + 1
     else
         CONFUSION_MATRIX(nState, index) = CONFUSION_MATRIX(nState, index) + 1
     end
    state_idx = 1:length(STATE);
    state_idx(nState) = [];
    timepos = [];
    for other_state = length(state_idx)
        diff = state_log(nState, :) - state_log( other_state,: );
        diff = abs(diff); % and then find the minimum val
        pos = find(diff==min(diff));
        timepos = [timepos, min(pos)/(R_State(nState + 1) - R_State(nState))];
    end
    timepos = min(timepos);
    TIME_PERCENT(nState) = TIME_PERCENT(nState) + timepos
end

if PLOT_SAVE
    gHandle_testing  = figure;
    %For plotting 
    
    FontSize   = 14;
    disp(strcat('Plotting! Please Wait'));
    subplot_1 = subplot(1,1,1,'Parent',gHandle_testing);
    fig_leg = {};
    stateLikelihood(find(stateLikelihood == 0)) = NaN;
    for sIdx = 1 : size(stateLikelihood,1)
        fig_leg{sIdx} = plot([1:length(stateLikelihood(sIdx,:))] * TIME_STEP,stateLikelihood(sIdx,:)',COLORS{sIdx},'LineWidth',2,'Parent',subplot_1);
        hold on;
    end
    title({'Cumulative Log-Likelihoods of Possible Sub-Tasks and Trained Model';...                                                                                                                        
      strcat('TrainingModels: ', METHOD,'-',ROBOT,'-',TASK,'-',TRAINING_SIM_REAL,'-', TRAINING_SUCCESS_FAILURE) ; ...
      strcat('TestingTask: '   , TESTING_SIM_REAL ,'\_', TESTING_SUCCESS_FAILURE ,'\_',char(FOLDERS_NAME))     ;  ...
      });
    grid on;
    axis auto
    xlabel('Time(s)','FontName','Times New Roman','FontSize',FontSize)
    ylabel('Cumulative Log-Likelihood','FontName','Times New Roman','FontSize',FontSize,'Rotation',90)
    set(gca,'xtick',[0:3:(length(data)* TIME_STEP)]);
    gridxy(R_State(:,:) * TIME_STEP,'Linestyle','--','Color',[.5 .5 .5],'linewidth',1);
    legendEntries = [fig_leg{1}, fig_leg{2}, fig_leg{3}, fig_leg{4}];
    h = legend(legendEntries,strcat('Sub-Task:',char(STATE(1))),...
                             strcat('Sub-Task:',char(STATE(2))),...
                             strcat('Sub-Task:',char(STATE(3))),...
                             strcat('Sub-Task:',char(STATE(4))),...
                             'Location','SouthWest');
    set(h,'Fontsize',FontSize);
    
    %{
    %Evoluting data 
    subplot_2 = subplot(2,1,2,'position', [left bottow width heigh],'Parent',gHandle_testing);
    cla(subplot_2);
    plot(data(:,1:obsIdx)','Parent',subplot_2); % for animation
    grid on;
    grid MINOR
    gridxy(obsIdx,'Linestyle','-','Color',[.5 .5 .5],'linewidth',0.6);
    xlim([0  length(data)]);
    %}

    if (exist(TESTING_RESULTS_PATH,'dir') == 0)
        mkdir(TESTING_RESULTS_PATH);
    end
    cd (TESTING_RESULTS_PATH);
    saveas(gHandle_testing, strcat('STATE_CLASSIFICATION','_',FOLDERS_NAME),'jpg');
end
end